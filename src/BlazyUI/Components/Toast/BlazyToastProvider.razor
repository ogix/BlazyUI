@namespace BlazyUI
@implements IDisposable

@foreach (var positionGroup in _toasts.GroupBy(t => t.Options.Position))
{
    <div class="toast @GetPositionClasses(positionGroup.Key) z-[1000]">
        @foreach (var toast in positionGroup)
        {
            <BlazyAlert Color="@GetBlazyAlertColor(toast.Type)" Style="@toast.Options.Style">
                <Icon>
                    @switch (toast.Type)
                    {
                        case BlazyToastType.Info:
                            <InfoIcon Class="w-6 h-6" />
                            break;
                        case BlazyToastType.Success:
                            <SuccessIcon Class="w-6 h-6" />
                            break;
                        case BlazyToastType.Warning:
                            <WarningIcon Class="w-6 h-6" />
                            break;
                        case BlazyToastType.Error:
                            <ErrorIcon Class="w-6 h-6" />
                            break;
                    }
                </Icon>
                <ChildContent>
                    <span>@toast.Message</span>
                    @if (toast.Options.ShowCloseButton)
                    {
                        <BlazyButton Size="BlazyButtonSize.Small" Style="BlazyButtonStyle.Ghost" OnClick="() => Remove(toast.Id)">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </BlazyButton>
                    }
                </ChildContent>
            </BlazyAlert>
        }
    </div>
}

@code {
    [Inject] private IBlazyToastService ToastService { get; set; } = default!;

    private BlazyToastService? _service;
    private IReadOnlyList<BlazyToastReference> _toasts = Array.Empty<BlazyToastReference>();
    private readonly Dictionary<Guid, Timer> _timers = new();

    protected override void OnInitialized()
    {
        _service = ToastService as BlazyToastService;
        if (_service != null)
        {
            _toasts = _service.Toasts;
            _service.OnChange += HandleChange;
        }
    }

    private void HandleChange()
    {
        if (_service != null)
        {
            _toasts = _service.Toasts;

            // Set up timers for new toasts with auto-dismiss
            foreach (var toast in _toasts)
            {
                if (toast.Options.Duration > 0 && !_timers.ContainsKey(toast.Id))
                {
                    var timer = new Timer(_ => InvokeAsync(() => Remove(toast.Id)), null, toast.Options.Duration, Timeout.Infinite);
                    _timers[toast.Id] = timer;
                }
            }
        }
        InvokeAsync(StateHasChanged);
    }

    private void Remove(Guid id)
    {
        if (_timers.TryGetValue(id, out var timer))
        {
            timer.Dispose();
            _timers.Remove(id);
        }
        _service?.Remove(id);
    }

    private static string GetPositionClasses(BlazyToastPosition position) => position switch
    {
        BlazyToastPosition.TopStart => "toast-start toast-top",
        BlazyToastPosition.TopCenter => "toast-center toast-top",
        BlazyToastPosition.TopEnd => "toast-end toast-top",
        BlazyToastPosition.MiddleStart => "toast-start toast-middle",
        BlazyToastPosition.MiddleCenter => "toast-center toast-middle",
        BlazyToastPosition.MiddleEnd => "toast-end toast-middle",
        BlazyToastPosition.BottomStart => "toast-start toast-bottom",
        BlazyToastPosition.BottomCenter => "toast-center toast-bottom",
        BlazyToastPosition.BottomEnd => "toast-end toast-bottom",
        _ => throw new ArgumentOutOfRangeException(nameof(position))
    };

    private static BlazyAlertColor GetBlazyAlertColor(BlazyToastType type) => type switch
    {
        BlazyToastType.Info => BlazyAlertColor.Info,
        BlazyToastType.Success => BlazyAlertColor.Success,
        BlazyToastType.Warning => BlazyAlertColor.Warning,
        BlazyToastType.Error => BlazyAlertColor.Error,
        _ => throw new ArgumentOutOfRangeException(nameof(type))
    };

    public void Dispose()
    {
        if (_service != null)
        {
            _service.OnChange -= HandleChange;
        }

        foreach (var timer in _timers.Values)
        {
            timer.Dispose();
        }
        _timers.Clear();
    }
}
